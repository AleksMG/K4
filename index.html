<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vigenère Bruteforcer — Works Offline</title>
  <style>
    body { background: #0d0d0d; color: #00ffcc; font-family: monospace; padding: 16px; }
    .field { margin: 8px 0; }
    input, textarea, button {
      background: #1a1a1a; color: #00ffcc; border: 1px solid #00aa88; padding: 6px; width: 100%; box-sizing: border-box;
    }
    button { background: #004433; cursor: pointer; font-weight: bold; }
    #progressBar { height: 20px; background: #111; border: 1px solid #007766; margin: 10px 0; }
    #progressFill { height: 100%; background: linear-gradient(to right, #005555, #00ffaa); width: 0%; transition: width 0.1s; }
    #results { background: #001100; border: 1px solid #007755; height: 300px; overflow-y: auto; padding: 8px; white-space: pre-wrap; }
    .match { background: #330033; color: #ff66ff; padding: 0 2px; border-radius: 2px; }
    .rating { color: #ffcc00; font-weight: bold; }
  </style>
</head>
<body>
  <h2>⚡ Vigenère Bruteforcer — No Server Needed</h2>

  <div class="field">
    <label>Alphabet (26 letters):</label>
    <input id="alphabet" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ">
  </div>

  <div class="field">
    <label>Ciphertext:</label>
    <textarea id="cipher" rows="3">OBKRUOXOGHULBSOLIFBBWFLRVQQPRNGKSSOTWTQSJQSSEKZZWATJKLUDIAWINFBNYPVTTMZFPKWGDKZXTJCDIGKUHUAUEKCAR</textarea>
  </div>

  <div class="field">
    <label>Key length (1–7 recommended):</label>
    <input id="keyLen" type="number" value="6" min="1" max="10">
  </div>

  <div class="field">
    <label>Keywords (comma-separated):</label>
    <input id="keywords" value="BERLIN,CLOCK,NORTHEAST,EAST">
  </div>

  <button onclick="startBrute()">▶ Start</button>
  <button onclick="stopBrute()">⏹ Stop</button>

  <div>Total combinations: <span id="totalCombi">0</span></div>
  <div>Tested: <span id="tested">0</span> | Speed: <span id="speed">0</span>/sec</div>
  <div id="progressBar"><div id="progressFill"></div></div>

  <div id="results"></div>

  <script>
    let shouldStop = false;
    let totalCombinations = 0;
    let testedCount = 0;
    let startTime = 0;
    const resultsCache = new Set();

    function escapeHtml(s) {
      return s.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[m] || m));
    }

    // Fast decrypt
    function decrypt(ctNum, keyIndices, alphabetSize) {
      const plain = new Uint8Array(ctNum.length);
      for (let i = 0; i < ctNum.length; i++) {
        let p = ctNum[i] - keyIndices[i % keyIndices.length];
        if (p <= 0) p += alphabetSize;
        plain[i] = p;
      }
      return plain;
    }

    // Find all matches
    function findMatches(plain, kwNums) {
      const matches = [];
      let score = 0;
      for (const { word, arr } of kwNums) {
        const len = arr.length;
        for (let start = 0; start <= plain.length - len; start++) {
          let ok = true;
          for (let j = 0; j < len; j++) {
            if (plain[start + j] !== arr[j]) { ok = false; break; }
          }
          if (ok) {
            matches.push({ start, end: start + len, word });
            score += word.length;
          }
        }
      }
      return { matches, score };
    }

    // Generate next key (base-N counter)
    function incrementKey(key, base) {
      let i = key.length - 1;
      while (i >= 0) {
        key[i]++;
        if (key[i] < base) return true;
        key[i] = 0;
        i--;
      }
      return false; // overflow → done
    }

    async function startBrute() {
      shouldStop = false;
      resultsCache.clear();
      document.getElementById('results').innerHTML = '';

      const alphabet = document.getElementById('alphabet').value.toUpperCase();
      const alphabetSize = alphabet.length;
      if (alphabetSize !== 26) {
        alert('For best results, use 26-letter alphabet.');
        return;
      }

      const cipherText = document.getElementById('cipher').value.replace(/[^A-Z]/g, '').toUpperCase();
      const keyLen = parseInt(document.getElementById('keyLen').value) || 6;
      if (keyLen < 1 || keyLen > 10) { alert('Key length 1–10'); return; }

      const keywords = document.getElementById('keywords').value
        .split(',').map(k => k.trim().toUpperCase()).filter(k => k.length >= 3);

      totalCombinations = Math.pow(26, keyLen);
      if (totalCombinations > 2e9) {
        if (!confirm(`Total: ${totalCombinations.toLocaleString()} keys. May take hours. Continue?`)) return;
      }

      // Convert to numbers
      const ctNum = new Uint8Array(cipherText.length);
      for (let i = 0; i < cipherText.length; i++) {
        ctNum[i] = alphabet.indexOf(cipherText[i]) + 1;
      }

      const kwNums = [];
      for (const kw of keywords) {
        const arr = new Uint8Array(kw.length);
        let valid = true;
        for (let i = 0; i < kw.length; i++) {
          const idx = alphabet.indexOf(kw[i]);
          if (idx === -1) { valid = false; break; }
          arr[i] = idx + 1;
        }
        if (valid) kwNums.push({ word: kw, arr: arr });
      }

      // UI
      document.getElementById('totalCombi').textContent = totalCombinations.toLocaleString();
      document.getElementById('tested').textContent = '0';
      document.getElementById('speed').textContent = '0';
      document.getElementById('progressFill').style.width = '0%';

      // Init
      const key = new Uint8Array(keyLen).fill(0);
      testedCount = 0;
      startTime = performance.now();
      const batchSize = 80000; // balance speed & responsiveness

      const processBatch = () => {
        if (shouldStop) return;

        for (let b = 0; b < batchSize; b++) {
          const plainBuf = decrypt(ctNum, key, 26);
          const { matches, score } = findMatches(plainBuf, kwNums);

          if (score > 0) {
            let keyStr = '';
            for (let i = 0; i < keyLen; i++) keyStr += alphabet[key[i]];
            if (!resultsCache.has(keyStr)) {
              resultsCache.add(keyStr);
              let plainStr = '';
              for (let p of plainBuf) plainStr += alphabet[p - 1];

              // Highlight all matches
              const sorted = matches.sort((a, b) => a.start - b.start);
              let lastEnd = 0;
              let highlighted = '';
              for (const m of sorted) {
                if (m.start < lastEnd) continue;
                highlighted += escapeHtml(plainStr.slice(lastEnd, m.start));
                highlighted += `<span class="match">${escapeHtml(m.word)}</span>`;
                lastEnd = m.end;
              }
              highlighted += escapeHtml(plainStr.slice(lastEnd));

              const resDiv = document.getElementById('results');
              resDiv.innerHTML += `<div><span class="rating">★${score}</span> [${keyStr}] ${highlighted}</div>\n`;
              resDiv.scrollTop = resDiv.scrollHeight;
            }
          }

          // Next key
          if (!incrementKey(key, 26)) {
            shouldStop = true;
            break;
          }

          testedCount++;
          if (testedCount >= totalCombinations) {
            shouldStop = true;
            break;
          }
        }

        // Update stats
        const now = performance.now();
        const elapsed = (now - startTime) / 1000;
        const speed = Math.round(testedCount / elapsed);
        const percent = (testedCount / totalCombinations) * 100;

        document.getElementById('tested').textContent = testedCount.toLocaleString();
        document.getElementById('speed').textContent = speed.toLocaleString();
        document.getElementById('progressFill').style.width = Math.min(percent, 100).toFixed(1) + '%';

        if (!shouldStop) {
          setTimeout(processBatch, 0); // yield to browser
        }
      };

      processBatch();
    }

    function stopBrute() {
      shouldStop = true;
    }
  </script>
</body>
</html>
