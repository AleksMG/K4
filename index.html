<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vigenère Bruteforcer — Stable & Fast</title>
  <style>
    body { background: #0d0d0d; color: #00ffcc; font-family: monospace; padding: 16px; }
    .field { margin: 8px 0; }
    input, textarea, button {
      background: #1a1a1a; color: #00ffcc; border: 1px solid #00aa88; padding: 6px; width: 100%; box-sizing: border-box;
    }
    button { background: #004433; cursor: pointer; font-weight: bold; }
    #progressBar { height: 20px; background: #111; border: 1px solid #007766; margin: 10px 0; }
    #progressFill { height: 100%; background: linear-gradient(to right, #005555, #00ffaa); width: 0%; transition: width 0.1s; }
    #results { background: #001100; border: 1px solid #007755; height: 300px; overflow-y: auto; padding: 8px; white-space: pre-wrap; }
    .match { background: #330033; color: #ff66ff; padding: 0 2px; border-radius: 2px; }
    .rating { color: #ffcc00; font-weight: bold; }
  </style>
</head>
<body>
  <h2>⚡ Vigenère Bruteforcer — Works</h2>

  <div class="field">
    <label>Alphabet (26 letters recommended):</label>
    <input id="alphabet" value="ABCDEFGHIJKLMNOPQRSTUVWXYZ">
  </div>

  <div class="field">
    <label>Ciphertext:</label>
    <textarea id="cipher" rows="3">OBKRUOXOGHULBSOLIFBBWFLRVQQPRNGKSSOTWTQSJQSSEKZZWATJKLUDIAWINFBNYPVTTMZFPKWGDKZXTJCDIGKUHUAUEKCAR</textarea>
  </div>

  <div class="field">
    <label>Key length (1–8 recommended):</label>
    <input id="keyLen" type="number" value="6" min="1">
  </div>

  <div class="field">
    <label>Keywords (comma-separated):</label>
    <input id="keywords" value="BERLIN,CLOCK,NORTHEAST,EAST">
  </div>

  <button onclick="startBrute()">▶ Start</button>
  <button onclick="stopBrute()">⏹ Stop</button>

  <div>Total combinations: <span id="totalCombi">0</span></div>
  <div>Tested: <span id="tested">0</span> | Speed: <span id="speed">0</span>/sec</div>
  <div id="progressBar"><div id="progressFill"></div></div>

  <div id="results"></div>

  <script>
    let workers = [];
    let shouldStop = false;
    let totalCombinations = 0;
    let testedCount = 0;
    let startTime = 0;
    const resultsCache = new Set();

    function escapeHtml(s) {
      return s.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[m] || m));
    }

    // === WORKER CODE (as string) ===
    const workerCode = `
      function decrypt(ctNum, keyIndices, alphabetSize) {
        const plain = new Uint8Array(ctNum.length);
        for (let i = 0; i < ctNum.length; i++) {
          let p = ctNum[i] - keyIndices[i % keyIndices.length];
          if (p <= 0) p += alphabetSize;
          plain[i] = p;
        }
        return plain;
      }

      function findMatches(plain, kwNums) {
        const matches = [];
        let score = 0;
        for (const { word, arr } of kwNums) {
          const len = arr.length;
          for (let start = 0; start <= plain.length - len; start++) {
            let match = true;
            for (let j = 0; j < len; j++) {
              if (plain[start + j] !== arr[j]) { match = false; break; }
            }
            if (match) {
              matches.push({ start, end: start + len, word });
              score += word.length;
            }
          }
        }
        return { matches, score };
      }

      function* generateKeys(alphabetSize, keyLen, prefix = []) {
        if (prefix.length === keyLen) {
          yield new Uint8Array(prefix);
          return;
        }
        for (let i = 0; i < alphabetSize; i++) {
          yield* generateKeys(alphabetSize, keyLen, [...prefix, i]);
        }
      }

      self.onmessage = function(e) {
        const { startChar, endChar, keyLen, alphabetSize, ctNum, kwNums, alphabet } = e.data;
        const results = [];
        const batchSize = 20;

        // Generate only keys where first char is in [startChar, endChar)
        function* limitedKeys() {
          for (let first = startChar; first < endChar; first++) {
            if (keyLen === 1) {
              yield new Uint8Array([first]);
            } else {
              for (const rest of generateKeys(alphabetSize, keyLen - 1)) {
                const full = new Uint8Array(keyLen);
                full[0] = first;
                full.set(rest, 1);
                yield full;
              }
            }
          }
        }

        let count = 0;
        for (const key of limitedKeys()) {
          const plainBuf = decrypt(ctNum, key, alphabetSize);
          const { matches, score } = findMatches(plainBuf, kwNums);
          if (score > 0) {
            let keyStr = '';
            for (let idx of key) keyStr += alphabet[idx];
            let plainStr = '';
            for (let p of plainBuf) plainStr += alphabet[p - 1];
            results.push({ key: keyStr, score, plain: plainStr, matches });
            if (results.length >= batchSize) {
              self.postMessage({ type: 'results', data: results });
              results.length = 0;
            }
          }
          count++;
          if (count % 50000 === 0) {
            self.postMessage({ type: 'progress', amount: count });
            count = 0;
          }
        }
        if (results.length > 0) {
          self.postMessage({ type: 'results', data: results });
        }
        self.postMessage({ type: 'done', total: count });
      };
    `;

    function startBrute() {
      stopBrute();
      shouldStop = false;
      resultsCache.clear();
      document.getElementById('results').innerHTML = '';

      const alphabet = document.getElementById('alphabet').value.toUpperCase();
      const alphabetSize = alphabet.length;
      if (alphabetSize < 2) { alert('Alphabet too short!'); return; }

      const cipherText = document.getElementById('cipher').value.replace(/[^A-Z]/g, '').toUpperCase();
      const keyLen = parseInt(document.getElementById('keyLen').value) || 1;
      if (keyLen < 1) { alert('Key length must be ≥1'); return; }

      const keywords = document.getElementById('keywords').value
        .split(',').map(k => k.trim().toUpperCase()).filter(k => k.length >= 3);

      // Total combinations
      const total = Math.pow(alphabetSize, keyLen);
      if (!isFinite(total) || total > 1e10) {
        if (!confirm(`Total: ${total.toExponential(2)} keys. May take hours. Continue?`)) return;
      }
      totalCombinations = total;

      // Convert cipher to numbers
      const ctNum = [];
      for (let ch of cipherText) {
        const idx = alphabet.indexOf(ch);
        if (idx !== -1) ctNum.push(idx + 1);
      }

      // Convert keywords
      const kwNums = [];
      for (const kw of keywords) {
        const arr = [];
        for (let ch of kw) {
          const idx = alphabet.indexOf(ch);
          if (idx === -1) { arr.length = 0; break; }
          arr.push(idx + 1);
        }
        if (arr.length === kw.length) {
          kwNums.push({ word: kw, arr: new Uint8Array(arr) });
        }
      }

      // UI
      document.getElementById('totalCombi').textContent = totalCombinations.toLocaleString();
      document.getElementById('tested').textContent = '0';
      document.getElementById('speed').textContent = '0';
      document.getElementById('progressFill').style.width = '0%';

      // Launch workers
      const numWorkers = Math.min(navigator.hardwareConcurrency || 4, alphabetSize);
      const charsPerWorker = Math.ceil(alphabetSize / numWorkers);
      workers = [];
      testedCount = 0;
      startTime = performance.now();

      for (let i = 0; i < numWorkers; i++) {
        const startChar = i * charsPerWorker;
        const endChar = Math.min(startChar + charsPerWorker, alphabetSize);
        if (startChar >= alphabetSize) break;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(blob));

        worker.onmessage = (e) => {
          if (e.data.type === 'results') {
            for (const r of e.data.data) {
              if (resultsCache.has(r.key)) continue;
              resultsCache.add(r.key);

              let highlighted = r.plain;
              const sorted = [...r.matches].sort((a, b) => a.start - b.start);
              let lastEnd = 0;
              let finalHtml = '';
              for (const m of sorted) {
                if (m.start < lastEnd) continue;
                finalHtml += escapeHtml(highlighted.slice(lastEnd, m.start));
                finalHtml += \`<span class="match">\${escapeHtml(m.word)}</span>\`;
                lastEnd = m.end;
              }
              finalHtml += escapeHtml(highlighted.slice(lastEnd));

              const resDiv = document.getElementById('results');
              resDiv.innerHTML += \`<div><span class="rating">★\${r.score}</span> [\${r.key}] \${finalHtml}</div>\n\`;
              resDiv.scrollTop = resDiv.scrollHeight;
            }
          } else if (e.data.type === 'progress') {
            testedCount += e.data.amount;
          } else if (e.data.type === 'done') {
            testedCount += e.data.total;
          }
        };

        worker.postMessage({
          startChar, endChar, keyLen, alphabetSize,
          ctNum: new Uint8Array(ctNum),
          kwNums,
          alphabet
        });

        workers.push(worker);
      }

      // Progress updater
      const updateProgress = () => {
        if (shouldStop) return;
        const now = performance.now();
        const elapsed = (now - startTime) / 1000;
        const speed = Math.round(testedCount / elapsed);
        const percent = (testedCount / totalCombinations) * 100;

        document.getElementById('tested').textContent = testedCount.toLocaleString();
        document.getElementById('speed').textContent = speed.toLocaleString();
        document.getElementById('progressFill').style.width = isNaN(percent) ? '0%' : Math.min(percent, 100).toFixed(1) + '%';

        if (testedCount < totalCombinations) {
          setTimeout(updateProgress, 100);
        }
      };
      updateProgress();
    }

    function stopBrute() {
      shouldStop = true;
      workers.forEach(w => w.terminate());
      workers = [];
    }
  </script>
</body>
</html>

